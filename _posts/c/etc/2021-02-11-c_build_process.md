---
layout: post
title:  "[C]C언어 빌드과정"
subtitle:   ""
date: 2021-02-11 03:45:51 +0900
categories: c
tags: etc
comments: true
---

이번장에서는 C언어 빌드 단계(4단계)에 대해 간단히 알아보도록 하겠습니다.

<h2>C언어의 빌드 단계(4단계)</h2>
1. 전처리(preprocessing)
2. 컴파일(compilation)
3. 어셈블(assembling)
4. 링크(linking)
<!-- 나중에 이미지 추가-->

※ 크게 컴파일(1,2,3단계)와 링크 단계로 보기도 합니다.
* * *
<h2>1. 전처리 단계</h2>
* **입력:** C언어 코드(.c)<br />**출력:** 트랜슬레이션 유닛(translation unit)
* 전처리 단계에서는 **트랜슬레이션 유닛(소스코드를 확장시킨 것)**을 만듭니다.
    1. 주석 제거(#include)
        * <&nbsp;> : 시스템 경로에서만 헤더파일을 검색
        * "&nbsp;" : 현재작업중인 디렉토리에서 우선 검색한 뒤, 시스템 경로에서 검색
    2. 매크로를 복붙 확장
    3. 인클루드(#include) 파일들을 복붙 확장
* **트랜슬레이션 유닛** 보는 법
    * (clang, gcc) 컴파일 명령어에 `-E`플래그를 넣으면 됩니다.

* * *
<h2>2. 컴파일 단계</h2>
* **입력:** 트랜슬레이션 유닛<br />**출력:** 어셈블리어 코드(.s)
* 어셈블리어 코드는 아직 정의를 모르는 심볼을 사용할 수 있습니다.
    * 심볼(symbol): 함수나 변수의 이름 등
    * 헤더를 통한 선언만으로 컴파일이 가능
    * 정의를 모르는 것들은 구멍으로 그대로 남겨둠(나중에 링크 단계에서 메꿔줌)
* 이 단계 이후부터 코드는 특정 플랫폼에서만 동작
<br />(C언어가 크로스 플랫폼이라는 주장은 컴파일되기 전까지 입니다)
* 어셈블리어는 기계코드와 거의 1:1 대응하는 언어입니다.    
* **어셈블리어 코드** 보는 법
    * `-S`플래그를 사용하면 어셈블리어 코드가 (.s)파일에 저장 됩니다.

* * *
<h2>3. 어셈블 단계</h2>
* **입력:** 어셈블리어 코드(.s)<br />**출력:** 오브젝트 코드(.o)
* (.c)파일에서 컴파일하는 것보다 (.o)파일을 컴파일 하는 것이 속도가 빠르다.
    * (.c)파일이 많으면 하나하나 구멍을 메꾸는과정과 함수 중복체크를 하는데 까다롭다.
    * (.c)파일을 하나씩 컴파일해서 오브젝트 파일로 저장<br />(파일을 수정해야할 때 효율적인 방법)
    * 하지만 프로젝트 컴파일을 빠르게 하기위해 C파일을 하나로 합치기도 한다고 합니다.<br />(파일을 수정해야할 때 비효율적)
* 오브젝트파일을 모아 (.a)라이브러리파일로 만들 수 있습니다.
* **오브젝트 코드** 보는 법
    * `-c`플래그를 사용하면 오브젝트파일(.o)이 생성됩니다.
    * (.o)오브젝트 파일은 일반 텍스트파일 편집기로는 볼 수 없기 때문에 "16진수 편집기"로 봐야합니다.(HexEdit, Hxo)

* * *
<h2>4. 링크 단계</h2>
* **입력:** 모든 오브젝트 코드들(.o)<br />**출력:** 최종실행 파일(.exe, .out)
* 모든 오브젝트 코드들을 모아서 구멍을 메꾼 뒤 실행파일로 저장합니다.
    * 만약 선언(구멍)만하고 그 함수를 제대로 구현을 하지않으면 오류메시지를 출력합니다.
    * 그 함수나 변수가 없어 실행할 방법이 없기에 오류가 납니다.