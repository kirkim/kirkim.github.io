---
layout: post
title:  "[C]해시(hash)"
subtitle:   ""
date: 2021-04-22 02:45:51 +0900
categories: c
tags: etc
comments: true 
---

* * *
<h1>1️⃣ 해시 테이블</h1>

* <b>값</b>을 저장하는 방법은 여러가지가 있지만 <b>다음 표</b>를 보면 알 수 있듯이 <rd>해시 테이블</rd>의 평균속도가 빠름을 알 수 있습니다. <b style="font_size:90%">(해시충돌이 일어나는 경우 탐색시간이 늘어남)</b>
<h4 align="right" style="font-size:80%">&lt; 출처:pocu아카데미 &gt;</h4>
<img src="https://kirkim.github.io/assets/img/c/hash1.png" alt="hash_speed" width="90%" style="margin-top:3%">

* <b>배열</b>을 이용하여 값이 있으면 <b>1</b>, 없으면 <b>0</b>을 저장하는 방법은 <rd>숫자가 커질경우</rd> 메모리적으로 <rd>비효율</rd>적 입니다.
<img src="https://kirkim.github.io/assets/img/c/hash2.png" alt="hash_speed" width="90%" style="margin-top:3%">

* 해쉬테이블의 종류는 여러가지이지만 가장 간단한 방법으로 `색인 = 입력값 % 10`과 같이 **입력값**을 **색인**으로 만듬으로써 일정범위의 크기로 만들 수 있습니다. 이 **색인**을 바로 **해시**라고 합니다.
    * 하지만 이러한 방법의 경우 <rd>중복</rd>의 경우가 있는데 다음과 같은 방법으로 줄일 수 있습니다.
        1. <b><rd>소수값</rd></b>으로 나누는 방법
        2. 중복될 경우 <rd>다음 빈칸에 저장</rd>하는 방법
<br /><br />

* * *
<h1>2️⃣ 해시 테이블 구현</h1>
<h2 style="color:#0e435c;">(1) 배열을 사용한 간단한 해시 테이블 예시</h2>

```c
#include <limits.h>

#define BUCKET_SIZE (23)
#define FALSE (-1)
#define TRUE (1)

/* 해시로 만들어주는 함수 */
int hash(int value)
{
    int hs;

    hs = value % BUCKET_SIZE;
    if (hs < 0)
        hs += BUCKET_SIZE;

    return (hs);
}

/* 해시테이블을 초기화시켜주는 함수 */
void init_hashtable(int *hashtable)
{
    for(int i; i < BUCKET_SIZE; i++)
        hashtable[i] = INT_MIN;
}

/* 해시테이블에서 값을 찾는 함수 */
int find_value(int value, int *hashtable)
{
    int i;
    int start_index;

    start_index = hash(value);
    i = start_index;

    do {
        if (hashtable[i] == value)
            return (i);
        else if (hashtable[i] == INT_MIN)
            return (FALSE);
        i = (i + 1) % BUCKET_SIZE;
    } while (i != start_index);

    return (FALSE);    
}

/* 해시테이블에 값을 추가하는 함수 */
int add_value(int value, int *hashtable)
{
    int i;
    int start_index;

    start_index = hash(value);
    i = start_index;

    do {
        if (hashtable[i] == value || hashtable[i] == INT_MIN)
        {
            hashtable[i] = value;
            return (TRUE);
        }
        i = (i + 1) % BUCKET_SIZE;
    } while (i != start_index);

    return (FALSE);
}
```