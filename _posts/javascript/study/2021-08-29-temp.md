---
layout: post
title: "[JavaScript]"
subtitle: ""
date: 2021-08-29 02:45:51 +0900
categories: javascript
tags: study
comments: true
---

<h1>1️⃣ 목표</h1>
<kline></kline>

- <b class="orange">Javascript</b>를 공부하다보니 **이전에 만든기능**들의 <b class="purple">수정할 점</b>들이 보이기 시작했습니다.
- **이번 포스트**에서는 다음의 <b class="purple">두가지 프로젝트</b>를 **보완**해볼 예정입니다.

<style>
  	iframe {
  		display: block;
  		width:80%;
  		height:420px;
  	}
</style>

<kline></kline>

<h2>&#91; 1 &#93; 마우스 이벤트</h2>

🍄 <a href="https://kirkim.github.io/javascript/2021/08/11/mouse_func.html" target="blank">addEventListener 써보기(마우스 이벤트) 포스트</a>👈🏻👈🏻<br>

<iframe src="/assets/js_study/mouseEvent/mouseEvent.html" scrolling="no"></iframe>

<kline></kline>

<h2>&#91; 2 &#93; Todo 리스트</h2>
🍄 <a href="https://kirkim.github.io/javascript/2021/08/16/todo_list.html" target="blank">ToDo리스트 만들기 포스트</a>👈🏻👈🏻<br>
<iframe src="/assets/js_study/todolist/todolist.html" scrolling="no"></iframe>

<h1>2️⃣ 마우스이벤트 프로젝트 수정</h1>
<h2 class="ksubsubject">(1) 수정하기 전 상태</h2>

- 먼저 <b class="orange">마우스이벤트 프로젝트</b>를 수정하겠습니다.
- <b class="brown">기존 js코드</b>는 다음과 같았습니다.

```javascript
const aa = document.querySelectorAll(".hello");

for (let i = 0; i < aa.length; i++) {
  function mouseEnterFunc() {
    aa[i].style.color = "#" + parseInt(Math.random() * 0xffffff).toString(16);
    aa[i].style.fontSize = "300%";
    aa[i].innerText = "Hello Mouse!";
  }
  function mouseLeaveFunc() {
    aa[i].style.color = "#" + parseInt(Math.random() * 0xffffff).toString(16);
    aa[i].style.fontSize = "200%";
    aa[i].innerText = "@@@@@@@@@@@";
  }
  aa[i].addEventListener("mouseenter", mouseEnterFunc);
  aa[i].addEventListener("mouseleave", mouseLeaveFunc);
}
```

- 이때당시 <b class="brown">콜백함수</b>를 잘 알지 못했고 위와 같이 `for문`을 돌려서 만들었습니다.
- 추후에 위와 같이 사용할때만 <b class="brown">함수</b>들은 **반복문**에서 빼주었고 <b class="green">이벤트를 지정해줄 떄</b>만 `forEach`를 이용하였습니다.

```javascript
const aa = document.querySelectorAll(".hello");

function mouseEnterFunc(event) {
  const value = event.target;
  value.style.color = "#" + parseInt(Math.random() * 0xffffff).toString(16);
  value.style.fontSize = "300%";
  value.innerText = "Hello Mouse!";
}
function mouseLeaveFunc(event) {
  const value = event.target;
  value.style.color = "#" + parseInt(Math.random() * 0xffffff).toString(16);
  value.style.fontSize = "200%";
  value.innerText = "@@@@@@@@@@@";
}

Array.from(aa).forEach((a) => {
  a.addEventListener("mouseenter", mouseEnterFunc);
  a.addEventListener("mouseleave", mouseLeaveFunc);
});
```

- 하지만 <b class="orange">이벤트 위임</b>을 이용하면 `forEach`로 **반복문**을 돌릴필요가 없습니다.
- 번외로 위 코드에서 `style.color`를 직접 바꾸는 것도 <b class="purple">매우 비효율</b>적인 작업입니다. 하지만 아직 **css**적으로 <b class="green">랜덤한 색</b>을 지정하는 방법을 모르기 때문에 **이번에 다루지 않겠습니다.**<b style="font-size:85%">(css의 style요소를 js에서 바꿔주는 것을 <rd>레이아웃(layout)</rd>까지 변경되는 작업이므로 <rd>트리거</rd>속도가 매우느려지고 비효율적으로 됩니다, 왠만하면 <b class="blue">Composite</b>선에서 변경되는 기능을 사용하는 것이 효율적입니다.)</b>

<kline></kline>

<h2 class="ksubsubject">(2) 이벤트 위임 적용하기(mouseenter, mouseleave)</h2>

- 먼저 위의 <b class="blue">코드</b>에서 수정할 부분은 다음과 같습니다.

```javascript
Array.from(aa).forEach((a) => {
  a.addEventListener("mouseenter", mouseEnterFunc);
  a.addEventListener("mouseleave", mouseLeaveFunc);
});
```

- <b class="brown">이벤트 위임</b>의 **대략적인** 구현을 말하자면 <span class="green">자식노드에 이벤트가 <b>중복</b></span>된다면 <b class="orange">부모노드</b>에 **이벤트를 할당**하는 것 입니다.
- 그렇다면 <b class="red">어떤 자식노드 이벤트</b>인지 어떻게 찾을 수 있을까? **각각의 자식노드**들을 서로다른 <b class="green">id</b>를 할당하여 구분하면 되지않을까 생각이듭니다.
- 그러나 <b class="orange">JavaScript</b>에서는 그럴 필요없이 <b class="green">자식노드와 부모노드</b>를 **구분할 수 있는 요소**로 구분만 해준다면 <b class="green">각각의 자식노드</b>에게 독립적으로 이벤트가 작동되도록 해줍니다.

```javascript
const body = document.querySelector("body");

body.addEventListener("mouseenter", (event) => {
  if (event.target.className === "hello") {
    mouseEnterFunc(event);
  }
});

body.addEventListener("mouseleave", (event) => {
  if (event.target.className === "hello") {
    mouseLeaveFunc(event);
  }
});
```

- <b class="green">자식노드와 부모노드</b>를 구분하는 요소로 <b class="blue">class</b>를 이용하였습니다.
- 하지만 생각한 것처럼 이벤트가 <b class="red">동작하지 않았습니다.</b>
- 그 이유로 <b class="orange">MDN</b>사이트에서는 <b class="blue">"mouseenter"</b>와 <b class="blue">"mouseleave"</b>이벤트에 대해 다음과 같이 말하고 있습니다.

> it doesn't bubble and it isn't sent to any descendants when the pointer is moved from one of its descendants physical space to its own physical space. <br>- mozilla(MDN)

- 즉, <b class="blue">"mouseenter"</b>와 <b class="blue">"mouseleave"</b>는 <b class="brown">bubble</b>이 아니기 때문에 **자식노드**로 **물리적 이동**이 일어나도 <b class="green">이벤트 포인터가 자식노드로 이동하지 않는다</b>고 합니다.

<img src="/assets/img/js/modify_project/1.png" width="40%" alt="is_bubble" />

- 위의 **이미지**와 같이 <b class="blue">"mouseenter"</b>와 <b class="blue">"mouseleave"</b>의 <b class="brown">bubble</b>속성값이 <b class="purple">false</b>로 되어 있습니다.

👉🏻👉🏻👉🏻 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseenter_event" blank="target">mouseenter 이벤트 - MDN</a><br>
👉🏻👉🏻👉🏻 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseleave_event" blank="target">mouseleave 이벤트 - MDN</a><br>

<kline></kline>

<h2 class="ksubsubject">(3) 이벤트 위임 적용하기(mouseover, mouseout)</h2>

- 그렇다면 <b class="green">부모위임</b>을 이용하기위해 <b class="brown">bubble</b>속성값이 <b class="purple">true</b>인 이벤트를 이용해야될 것 같습니다.
- 다행히 그중에서 <b class="blue">"mouseenter"</b>와 <b class="blue">"mouseleave"</b>와 **같은 기능**을 하는 이벤트가 있는데 <b class="purple">"mouseover"</b>와 <b class="purple">"mouseout"</b>이벤트입니다.

```javascript
const body = document.querySelector("body");

body.addEventListener("mouseover", (event) => {
  if (event.target.className === "hello") {
    mouseEnterFunc(event);
  }
});

body.addEventListener("mouseout", (event) => {
  if (event.target.className === "hello") {
    mouseLeaveFunc(event);
  }
});
```

- 하지만 <b class="red">깊은 계층 구조</b>를 사용하면 **전송 되는 이벤트 수**가 상당히 많아져 **심각한 성능 저하**를 일으킬 수 있다고 합니다.

<kline></kline>

<h2 class="ksubsubject">(4) mouseover성능문제 생각해보기</h2>

- <b class="purple">"mouseover"</b>와 <b class="purple">"mouseout"</b>이벤트를 이용하여 **성공적**으로 <b class="blue">이벤트위임</b>을 적용시켰습니다.
- 하지만 굳이 <b class="blue">이벤트위임</b>을 사용할 필요가 있을까 의문이듭니다. <b class="orange">MDN</b>사이트에서도 **잘못**사용하면 <b class="red">심각한 성능 저하</b>를 일으킬 수 있다고 합니다.
- 다음은 <b class="purple">"mouseover"</b>이벤트가 **정확히 어떻게 동작**하는지 확인하기위한 예시입니다.
<h3 class="ksubsubject">&#91; index.html &#93;</h3>
<img src="/assets/img/js/modify_project/2.png" width="80%" alt="html" />
<h3 class="ksubsubject">&#91; app.js &#93;</h3>

```javascript
const body = document.querySelector("body");

function aaa(event) {
  event.target.style.backgroundColor =
    "#" + parseInt(Math.random() * 0xffffff).toString(16);
}

body.addEventListener("mouseover", aaa);
```

<iframe src="/assets/js_study/mouseEvent2/mouseEvent2.html" scrolling="no"></iframe>

- <b class="purple">자식노드마다</b> **이벤트**가 감지되어 동작됨을 알 수 있습니다.
- 다시말해서 만약 <b class="blue">특정 자식노드</b>에서만 **이벤트**가 동작하도록하기 위해 다음과 같이 작성하는 것은 성능적으로 **비효율**적입니다.

```javascript
body.addEventListener("mouseover", (event) => {
  if (event.target.className === "hello") {
    mouseEnterFunc(event);
  }
});
```

- <b class="green">"click"</b>과 같은 이벤트는 **의도적**으로 동작하는 것이기 때문에 <b class="brown">이벤트 위임</b>을 쉽게 고려할 수 있지만 <b class="green">"mouseover"</b>와 같은 이벤트는 **의도하지 않아도** 계속해서 일어나는 동작이기 때문에 **상황에 따라서** <b class="green">"mouseenter"</b>와 비교하여 알맞게 선택하여 사용하는 것이 좋을 것 같습니다.
