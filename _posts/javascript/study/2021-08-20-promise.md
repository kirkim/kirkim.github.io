---
layout: post
title: "[JavaScript] 비동기,동기,Promise,async 공부하기"
subtitle: ""
date: 2021-08-20 03:45:51 +0900
categories: javascript
tags: study
comments: true
---

<h1>1️⃣ 목표</h1>
<kline></kline>

1. 동기와 비동기 프로그래밍 이해
2. 콜백 함수를 이용하여 비동기처리
3. Promise사용법 배우기
4. async사용법 배우기

<h1 class="ksubject">2️⃣ 동기와 비동기</h1>
<h2 style="color:#0e435c;">(1) 동기(Synchronous)</h2>

- <b class="green">동기</b>형 함수들만 있으면 단순히 <b class="blue">작성된 순서</b>로 코드가 실행됩니다.

```javascript
console.log(1);
console.log(2);
console.log(3);
```

<kkr>
1<br>
2<br>
3<br>
</kkr>

<kline></kline>

<h2 style="color:#0e435c;">(2) 비동기(Asynchronous)</h2>

- 만약 <rd>하나의 함수</rd>가 처리하는데 **시간이 오래**걸린다면 그다음번 코드는 끝날때까지 **대기** 하게 됩니다.
- 실제로 서버에서 **클라이언트의 입출력(IO)**에서 지연이 많이 발생한다고 합니다. 만약 <b class="blue">클라이언트의 입출력 빈도</b>가 더 늘어난다면 <rd>서버</rd>는 무한대기상태에 빠지게 될 것입니다.
- 이때 <b class="purple">비동기</b>프로그래밍을 이용하면 좀 더 효율적으로 처리할 수 있습니다. <b style="font-size:90%">(예를들어 멀티쓰레드 방식으로 동시에 처리)</b>
- 하지만 <b class="orange">자바스크립트</b>는 <b class="blue">싱글쓰레드</b>로 처리합니다. 그대신에 <b class="gree">웹 브라우저</b>에서 제공하는 <b class="gree">API</b>를 이용하면 **웹에 있는 js엔진**에서 <rd>비동기적</rd>으로 처리해줍니다.
- <b class="gree">웹API</b>의 대표적인 예로 `setTimeout()`**콜백 함수**가 있습니다.

```javascript
console.log(1);
setTimeout(() => console.log(2), 1000);
console.log(3);
```

<kkr>
1<br>
3<br>
2<br>
</kkr>

<h1 class="ksubject">3️⃣ call back 함수로 비동기 처리하기</h1>
<h2 style="color:#0e435c;">(1) 비동기를 동기 프로그래밍 처리하기</h2>

- 하지만 **비동기**로 처리된 후의 값이 필요한 경우에는 <b class="blue">동기적</b>으로 처리해줄 수 밖에 없습니다.
- 이때 **콜백함수**를 이용하면되는데 <rd>처리를 실패</rd>했을때 처리도 고려하여 코드를 구성하여야 합니다.
- 간단한 예시로 <b class="green">Popcorn메이커</b>를 만들어 봤습니다.

<kline></kline>

<h2 style="color:#0e435c;">(2) call back함수 예시(Popcorn메이커)</h2>

```javascript
class Cooker {
  inspectFood(food, available, onError) {
    console.log("getting food...");
    setTimeout(() => {
      if (food === "🌽" || food === "🥔") {
        available(food);
      } else {
        onError(new Error("no food available"));
      }
    }, 2000);
  }
  makePopcorn(food, available, onError) {
    console.log("cooking...");
    setTimeout(() => {
      if (food === "🌽") {
        available(`${food} => 🍿`);
      } else {
        onError(new Error(`${food} => ❌`));
      }
    }, 2000);
  }
}
```

- 위의 코드는 다음의 메소드를 가진 <b class="green">Cooker 클래스</b>입니다.
  1.  <b class="blue">식재료</b>를 **유효한 식재료인지 검사**하는 `inspectFood()`메소드
  2.  <b class="blue">식재료</b>로 **팝콘을 만드는** `makePopcorn()`메소드

<kline></kline>

<h2 style="color:#0e435c;">(3) Popcorn메이커(call back) 사용 해보기</h2>

```javascript
const cooker = new Cooker();
const CORN = "🌽";
const POTATO = "🥔";
const APPLE = "🍎";

const food = CORN; // 사용자가 임의의 음식 설정

cooker.inspectFood(
  food,
  (availableFood) => {
    cooker.makePopcorn(
      availableFood,
      (availablePopcorn) => {
        console.log(availablePopcorn);
      },
      (error) => {
        console.log(error);
      }
    );
  },
  (error) => {
    console.log(error);
  }
);
```

<div class="A-20_out">
	<h3 id="A-20_title">PopcornMaker</h3>
	<div id="A-20_btn">
		<button id="corn"> 🌽 </button>
		<button id="potato"> 🥔 </button>
		<button id="apple"> 🍎 </button>
	</div>
	<div id="out">
		<span id="base" class="hidden">inspect the food...<br></span>
		<!--corn-->
		<span id="c1" class="hidden">cooking...<br></span>
		<span id="c2" class="hidden">🌽 => 🍿</span>
		<!--potato-->
		<span id="p1" class="hidden">cooking...<br></span>
		<span id="p2" class="hidden">Error: 🥔 => ❌</span>
		<!--apple-->
		<span id="a1" class="hidden">Error: no food available<br></span>
	</div>
</div>

- 위에서 🌽 와 🥔 의 경우 <b>출력</b>을 보면 <b class="purple">재료를 검사할때까지</b> <b>기다린 후</b> <b class="green">요리를 시작 합니다.</b>

<kline></kline>

<h2 style="color:#0e435c;">(4) Popcorn메이커(call back)의 단점</h2>

- **위에서 파악한** <b class="blue">Popcorn메이커</b>는 사용하는데 있어서 <b class="red">가독성</b>이 너무 떨어집니다. <b style="font-size:85%">(callback함수의 중첩...)</b>
- <b class="blue">Popcorn메이커</b>는 **콜백함수**가 겨우 <rd>2단계</rd>로만 사용됐는데도 불구하고 **코드를 읽기**가 쉽지않습니다. **대규모 프로젝트**에서는 <b class="blue">비동기 처리</b>가 좀 더 깊게 구현할때가 있을 텐데 만약 이런식으로 <b class="green">콜백함수</b>를 사용한다면 **코드를 알아보기**는 커녕 <rd>유지보수</rd>조차 할 수 없을 것 입니다.

<h1 class="ksubject">4️⃣ Promise</h1>
<h2 style="color:#0e435c;">(1) Promise기본사용</h2>

- Promise를 사용하면 <b class="red">콜백함수</b>보다 **더 깔끔하게** **호출**하여 사용할 수 있습니다.

```javascript
/* 방법 1 */
sampleFunc(param) {
	return new Promise((resolve, reject) => {
		/* 비동기함수 생략 */
		/* 성공시 */
		resolve(a);
		/* 실패시 */
		reject(b);
	})
}

/* 방법 2 */
const sample = new Promise((resolve, reject) => {
	/* 생략 */
})
```

- Promise는 **Javascript**에서 기본적으로 제공하는 오브젝트입니다. 위처럼 **두가지**방법으로 사용이 가능한데 <b class="red">방법 2</b>의 방법은 <b class="red">비추천하는 선언</b>방법 입니다. 그 이유는 **선언**과 동시에 **Promise**가 호출되어 실행되기 때문입니다. <b style="font-size:85%">(Promise는 필요에 따라 선택적으로 사용할때가 많으므로 방법1을 이용하는 것이 나을 것같다.)</b>
- **Promise**는 <b class="purple">비동기 진행 중</b> 일때는 <b class="purple">pending(대기)</b>상태에 있다가 <b class="green">비동기 처리가 완료</b>되면 <b class="green">fulfilled(이행)</b>상태로 되고 <b class="red">비동기 처리가 실패</b>하면 <b class="red">rejected(실패)</b>상태가 됩니다.
- 간단하게 <b class="blue">처리성공시 resolve</b>를 <b class="red">처리실패시 reject</b>콜백함수를 줍니다.
- 어떻게보면 **콜백함수**로 만든 것과 별차이가 없어보이지만 <rd>consumer(사용)</rd>하는 방법에서 큰차이가 나며 <b class="orange">Promise가 압도적으로 깔끔합니다.</b>

<kline></kline>

<h2 style="color:#0e435c;">(2) Popcorn메이커 Promise로 변환하기</h2>

```javascript
class Cooker {
  inspectFood(food) {
    return new Promise((resolve, reject) => {
      console.log("getting food...");
      setTimeout(() => {
        if (food === "🌽" || food === "🥔") {
          resolve(food);
        } else {
          reject(new Error("no food available"));
        }
      }, 1000);
    });
  }

  makePopcorn(food) {
    return new Promise((resolve, reject) => {
      console.log("cooking...");
      setTimeout(() => {
        if (food === "🌽") {
          resolve(`${food} => 🍿`);
        } else {
          reject(new Error(`${food} => ❌`));
        }
      }, 1000);
    });
  }
}
```

- **콜백함수**와 <b class="blue">복잡도</b>면에서는 별차이가 없어보입니다. 이번엔 **사용(consumer)**코드를 보겠습니다.
<div class="explain-cover">
    <div class="explain-left" style="padding-top:1%">
        <h4 align="middle" style="color:#0e435c;">&lt; 콜백함수 consumers&gt;</h4>
        <img src="https://kirkim.github.io/assets/img/js/promise/1.png" alt="callback_consumers" width="100%">
    </div>
    <div class="explain-right" style="padding-top:1%">
        <h4 align="middle" style="color:#0e435c;">&lt; 프로미스 consumers&gt;</h4>
        <img src="https://kirkim.github.io/assets/img/js/promise/2.png" alt="promise_consumers" width="100%">
    </div>
</div>

- <b class="red">2단계</b>구성된 **비동기처리**지만 **프로미스(promise)**가 <b class="red">눈에 띄게</b> 깔끔함을 알 수 있습니다.
- **프로미스(Promise)**는 **Promise 오브젝트**를 반환하기 때문에 연달아서 `then, catch, finally`와 같은 **Promise관련 메소드**를 사용할 수 있습니다.
- 먼저 <b class="blue">then</b>은 **앞선**처리가 **성공**하면 호출됩니다.
- <b class="red">catch</b>는 `reject`를 감지하여 <rd>에러값을 처리</rd>합니다.
- <b class="green">.finally</b>는 **성공유무를 떠나서** 반드시 호출됩니다. <b style="font-size:85%">(try-catch구문에서 쓰임과 비슷)</b>

<h1 class="ksubject">5️⃣ Async</h1>
<h2 style="color:#0e435c;">(1) </h2>

<script>
	const Form = document.querySelector(".A-20_out");
	const outForm = document.querySelector(".A-20_out #out");
	const cornButton = Form.querySelector("#corn");
	const potatoButton = Form.querySelector("#potato");
	const appleButton = Form.querySelector("#apple");
	const base = document.querySelector(".A-20_out #out #base");
	const corn1 = document.querySelector(".A-20_out #out #c1");
	const corn2 = document.querySelector(".A-20_out #out #c2");
	const potato1 = document.querySelector(".A-20_out #out #p1");
	const potato2 = document.querySelector(".A-20_out #out #p2");
	const apple1 = document.querySelector(".A-20_out #out #a1");
	let timer1;
	let timer2;

    function addHidden() {
    	clearTimeout(timer1);
    	clearTimeout(timer2);
    	corn1.classList.add("hidden");
    	corn2.classList.add("hidden");
    	potato1.classList.add("hidden");
    	potato2.classList.add("hidden");
    	apple1.classList.add("hidden");
    }

    function inputCorn() {
    	addHidden();
    	base.classList.remove("hidden");
    	timer1 = setTimeout(() => {
    		corn1.classList.remove("hidden");
    	}, 2000);
    	timer2 = setTimeout(() => {
    		corn2.classList.remove("hidden");
    	}, 4000);
    }

    function inputPotato() {
    	addHidden();
    	base.classList.remove("hidden");
    	timer1 = setTimeout(() => {
    		potato1.classList.remove("hidden");
    	}, 2000);
    	timer2 = setTimeout(() => {
    		potato2.classList.remove("hidden");
    	}, 4000);
    }

    function inputApple() {
    	addHidden();
    	base.classList.remove("hidden");
    	timer1 = setTimeout(() => {
    		apple1.classList.remove("hidden");
    	}, 2000);
    }

	if (Form) {
      cornButton.addEventListener("click", inputCorn);
      potatoButton.addEventListener("click", inputPotato);
      appleButton.addEventListener("click", inputApple);
	}

</script>

<style>
	.A-20_out {
	  display: flex;
	  align-items: center;
	  flex-direction: column;
	}
	.A-20_out #out {
	  padding-left: 6px;
	  color: white;
	  width: 50%;
	  height: 140px;
	  background-color: rgb(42, 44, 48);
	}

	#A-20_title {
	  padding-left: 3px;
	  padding-right: 3px;
	  width: 50%;
	  margin: 0px;
	  text-align: center;
	  background-color: rgb(183, 252, 73);
	}

	#A-20_btn {
	  display: flex;
  	  justify-content: space-around;
	  padding-left: 3px;
	  padding-right: 3px;
	  background-color: rgb(200, 229, 186);
	  width: 50%;
	}

	.A-20_out button {
	  font-size: 30px;
	  background-color: transparent;
	  border: none;
	  outline: none;
	  cursor: pointer;
	  transition: transform 300ms ease;
	}

	.A-20_out button:hover {
	  transform: scale(1.2);
	}

	.hidden {
	  display: none;
	}
</style>
