---
layout: post
title: "[JavaScript] 비동기(asynchronous)"
subtitle: ""
date: 2021-08-20 03:45:51 +0900
categories: javascript
tags: study
comments: true
---

<h1>1️⃣ 목표</h1>
<kline></kline>

1. 콜백 함수를 이용하여 비동기 프로그래밍해보기
2. Promise사용법 배우기
3. async사용법 배우기

<h1 class="ksubject">2️⃣ 동기와 비동기</h1>
<h2 style="color:#0e435c;">(1) 동기(Synchronous)</h2>

- <b class="green">동기</b>형 함수들만 있으면 단순히 <b class="blue">절차지향적</b>으로 코드가 실행됩니다.

```javascript
console.log(1);
console.log(2);
console.log(3);
```

<kkr>
1<br>
2<br>
3<br>
</kkr>

<kline></kline>

<h2 style="color:#0e435c;">(2) 비동기(Asynchronous)</h2>

- 만약 <rd>하나의 함수</rd>가 처리하는데 **시간이 오래**걸린다면 그다음번 코드는 끝날때까지 **대기** 하게 됩니다.
- 실제로 서버에서 **클라이언트의 입출력(IO)**에서 지연이 많이 발생한다고 합니다. 만약 <b class="blue">클라이언트의 입출력 빈도</b>가 더 늘어난다면 <rd>서버</rd>는 무한대기상태에 빠지게 될 것입니다.
- <h1 class="ksubject">3️⃣ call back 함수</h1>
  <h2 style="color:#0e435c;">(1) call back함수 예시(Popcorn메이커)</h2>

```javascript
class Cooker {
  inspectFood(food, available, onError) {
    console.log("getting food...");
    setTimeout(() => {
      if (food === "🌽" || food === "🥔") {
        available(food);
      } else {
        onError(new Error("no food available"));
      }
    }, 2000);
  }
  makePopcorn(food, available, onError) {
    console.log("cooking...");
    setTimeout(() => {
      if (food === "🌽") {
        available(`${food} => 🍿`);
      } else {
        onError(`${food} => ❌`);
      }
    }, 2000);
  }
}
```

- 위의 코드는 다음의 메소드를 가진 <b class="green">Cooker 클래스</b>입니다.
  1.  <b class="blue">식재료</b>를 **유효한 식재료인지 검사**하는 `inspectFood()`메소드
  2.  <b class="blue">식재료</b>로 **팝콘을 만드는** `makePopcorn()`메소드

<kline></kline>

<h2 style="color:#0e435c;">(2) Popcorn메이커(call back) 사용 해보기</h2>

```javascript
const cooker = new Cooker();
const CORN = "🌽";
const POTATO = "🥔";
const APPLE = "🍎";

const food = CORN; // 사용자가 임의의 음식 설정

cooker.inspectFood(
  food,
  (availableFood) => {
    cooker.makePopcorn(
      availableFood,
      (availablePopcorn) => {
        console.log("success!");
        console.log(availablePopcorn);
      },
      (error) => {
        console.log("fail...");
        console.log(error);
      }
    );
  },
  (error) => {
    console.log(error);
  }
);
```

<div class="A-20_out">
	<h3 id="A-20_title">PopcornMaker</h3>
	<div id="A-20_btn">
		<button id="corn"> 🌽 </button>
		<button id="potato"> 🥔 </button>
		<button id="apple"> 🍎 </button>
	</div>
	<div id="out">
		<span id="base" class="hidden">inspect the food...<br></span>
		<!--corn-->
		<span id="c1" class="hidden">cooking...<br></span>
		<span id="c2" class="hidden">success!<br>🌽 => 🍿</span>
		<!--potato-->
		<span id="p1" class="hidden">cooking...<br></span>
		<span id="p2" class="hidden">fail...<br>🥔 => ❌</span>
		<!--apple-->
		<span id="a1" class="hidden">Error: no food available<br></span>
	</div>
</div>

- 위에서 🌽 와 🥔 의 경우 <b>출력</b>을 보면 <b class="purple">재료를 검사할때까지</b> <b>기다린 후</b> <b class="green">요리를 시작 합니다.</b>
- 결국 <b class="purple">재료를 검사시간</b>이 <b class="purple">5초</b>, <b class="green">요리하는 시간</b>이 <b class="green">6초</b>라면 <b class="red">11초</b>를 기다리면 <b class="blue">요리 성공여부</b>를 알 수 있습니다.

<kline></kline>

<h2 style="color:#0e435c;">(3) Popcorn메이커(call back)의 단점</h2>

- **위에서 파악한** <b class="blue">Popcorn메이커</b>는 사용하는데 있어서 <b class="red">가독성</b>이 너무 떨어집니다. <b style="font-size:85%">(callback함수의 중첩...)</b>

<h1 class="ksubject">4️⃣ Promise</h1>
<h2 style="color:#0e435c;">(1) </h2>

<script>
	const Form = document.querySelector(".A-20_out");
	const outForm = document.querySelector(".A-20_out #out");
	const cornButton = Form.querySelector("#corn");
	const potatoButton = Form.querySelector("#potato");
	const appleButton = Form.querySelector("#apple");
	const base = document.querySelector(".A-20_out #out #base");
	const corn1 = document.querySelector(".A-20_out #out #c1");
	const corn2 = document.querySelector(".A-20_out #out #c2");
	const potato1 = document.querySelector(".A-20_out #out #p1");
	const potato2 = document.querySelector(".A-20_out #out #p2");
	const apple1 = document.querySelector(".A-20_out #out #a1");
	let timer1;
	let timer2;


	function addHidden() {
		clearTimeout(timer1);
		clearTimeout(timer2);
		corn1.classList.add("hidden");
		corn2.classList.add("hidden");
		potato1.classList.add("hidden");
		potato2.classList.add("hidden");
		apple1.classList.add("hidden");
	}

	function inputCorn() {
		addHidden();
		base.classList.remove("hidden");
		timer1 = setTimeout(() => {
			corn1.classList.remove("hidden");
		}, 2000);
		timer2 = setTimeout(() => {
			corn2.classList.remove("hidden");
		}, 4000);
	}

	function inputPotato() {
		addHidden();
		base.classList.remove("hidden");
		timer1 = setTimeout(() => {
			potato1.classList.remove("hidden");
		}, 2000);
		timer2 = setTimeout(() => {
			potato2.classList.remove("hidden");
		}, 4000);
	}

	function inputApple() {
		addHidden();
		base.classList.remove("hidden");
		timer1 = setTimeout(() => {
			apple1.classList.remove("hidden");
		}, 2000);
	}

	cornButton.addEventListener("click", inputCorn);
	potatoButton.addEventListener("click", inputPotato);
	appleButton.addEventListener("click", inputApple);
</script>

<style>
	.A-20_out {
	  display: flex;
	  align-items: center;
	  flex-direction: column;
	}
	.A-20_out #out {
	  padding-left: 6px;
	  color: white;
	  width: 50%;
	  height: 140px;
	  background-color: rgb(42, 44, 48);
	}

	#A-20_title {
	  padding-left: 3px;
	  padding-right: 3px;
	  width: 50%;
	  margin: 0px;
	  text-align: center;
	  background-color: rgb(183, 252, 73);
	}

	#A-20_btn {
	  display: flex;
  	  justify-content: space-around;
	  padding-left: 3px;
	  padding-right: 3px;
	  background-color: rgb(200, 229, 186);
	  width: 50%;
	}

	.A-20_out button {
	  font-size: 30px;
	  background-color: transparent;
	  border: none;
	  outline: none;
	  cursor: pointer;
	  transition: transform 300ms ease;
	}

	.A-20_out button:hover {
	  transform: scale(1.2);
	}

	.hidden {
	  display: none;
	}
</style>
