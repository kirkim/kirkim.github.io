---
layout: post
title:  "[cub3d]"
subtitle:   ""
date: 2021-06-27 02:45:51 +0900
categories: 42seoul
tags: cub3d
comments: true 
---

* * *
<h1>1️⃣ 목표</h1>

* 이번 목표는 미니맵상에서 <rd>플레이어(player)의 광선(ray)</rd>을 구현하는 것이 목표입니다.
* 이때 <rd>광선(ray)</rd>은 <rd>벽(wall)</rd>을 통과하지 못합니다.
* 즉, **player**부터 **벽(wall)**까지의 <rd>거리(distance)</rd>를 구할 수도 있습니다. 이 <rd>거리(distance)</rd>것이 이번 목표에서 가장중요한 부분인데, 여기서 구한 <rd>거리(distance)</rd>는 향후에 <rd>3D</rd>로 이미지를 구현할 때 중요한 요소가 될 것입니다.
<br><br>

* * *
<h1>2️⃣ draw_ray함수 구현</h1>

```c
/* cub3d.h */
#define RAY_RANGE (PI / 3.0)
#define RAY_COUNT 121  // It must be bigger than 2 and recommend odd numbers.

/* ray.c */
void    draw_ray(t_god *god)
{
    double angle;
    double maxAngle;

    angle = god->player.rotationAngle;
    maxAngle = god->player.rotationAngle + (RAY_RANGE / 2.0);

    while (angle <= maxAngle)
    {
        draw_one_ray(god, angle);
        draw_one_ray(god, angle - (RAY_RANGE / 2.0));
        angle += (RAY_RANGE / 2.0) / ((RAY_COUNT - 1) / 2.0);
    }
}
```

* `RAY_RANGE`는 **player**의 시야각을 나타냅니다. 무난하게 `(PI / 3)`(60도)로 **시야범위**를  **매크로**로 정의했습니다.
* **player**의 <rd>시야각도</rd>는 `player.rotationAngle`입니다. 그렇기 때문에 `player.rotationAngle`을 기준으로 양옆으로 `시야(RAY_RANGE / 2)`까지가 <rd>시야범위</rd>가 됩니다.
* `RAY_COUNT`는 광선의 갯수를 지정해줍니다. 하지만 만들어준 `while`문의 특성상 항상 <rd>2개 이상의</rd>의 광선이 그려집니다.<b style="font-size:85%"> (광선을 한개씩 그리도록 while문을 구성해도 되지만 `RAY_COUNT`를 의도적으로 2개이상 지정해주는 것은 어려운일이 아니기 때문에 그대로 나뒀습니다. + while문을 한번이라도 적게 돌리는 것이 성능향상에 도움이 될듯..)</b>
<br><br>

* * *
<h1>2️⃣ draw_one_ray함수</h1>
<h2 style="color:#0e435c;">(1) draw_one_ray함수 구현</h2>

```c
void    draw_one_ray(t_god *god, double angle)
{
    t_dpable_ray horz;
    t_dpable_ray vert;

    ray_init(&god->ray, angle);
    cal_horz_ray(god, &horz);
    cal_vert_ray(god, &vert);

    if (vert.distance < horz.distance) {
        god->ray.wall_hitX = vert.wall_hitX;
        god->ray.wall_hitY = vert.wall_hitY;
        god->ray.distance = vert.distance;
        god->ray.wasHit_vertical = TRUE;
    } else {
        god->ray.wall_hitX = horz.wall_hitX;
        god->ray.wall_hitY = horz.wall_hitY;
        god->ray.distance = horz.distance;
        god->ray.wasHit_vertical = FALSE;
    }
    draw_line(god, god->player.x, god->player.y, god->ray.wall_hitX, god->ray.wall_hitY);
}
```

* 위의 `draw_one_ray`함수에는 다음과 같은 **새로운 함수**와 **새로운 구조체 변수**를 포함하고 있습니다.
    * `t_dpable_ray`구조체
    * `ray_init`함수
    * `cal_horz_ray`함수
    * `cal_vert_ray`함수
    * `draw_line`함수

* * *
<h2 style="color:#0e435c;">(2) t_dpable_ray 구조체</h2>

```c
typedef struct s_dpable_ray {
    double  xintercept;
    double  yintercept;
    double  xstep;
    double  ystep;
    int     found_wallHit;
    double  wall_hitX;
    double  wall_hitY;
    double  distance;
} t_dpable_ray;
```

* **disposable**은 **"일회용"**이라는 뜻으로 구조체이름을 `t_dpable_ray`로 작명하였습니다.
* 각각의 요소들은 <rd>광선을 한개 그릴 때만 유효한 요소들</rd>입니다.

* * *
<h2 style="color:#0e435c;">(3) ray_init함수</h2>

```c
/* cub3d.h */
typedef struct s_ray {
    double  ray_angle;
    double  wall_hitX;
    double  wall_hitY;
    double  distance;
    int     wasHit_vertical;
    int     isRay_facingDown;
    int     isRay_facingUp;
    int     isRay_facingRight;
    int     isRay_facingLeft;
} t_ray;

typedef struct s_god {
    /* 코드 생략 */
    t_ray    ray;
} t_god;

/* ray.c */
void ray_init(t_ray *ray, double rayAngle)
{
    ray->ray_angle = rayAngle;
    ray->wall_hitX = 0;
    ray->wall_hitY = 0;
    ray->distance = 0;
    ray->wasHit_vertical = FALSE;

    ray->isRay_facingDown = ray->ray_angle > 0 && ray->ray_angle < PI;
    ray->isRay_facingUp = !ray->isRay_facingDown;
    ray->isRay_facingRight = ray->ray_angle < 0.5 * PI || ray->ray_angle > 1.5 * PI;
    ray->isRay_facingLeft = !ray->isRay_facingRight;
}
```

* `t_ray ray`는 `t_god`구조체에 포홤되어 있는 구조체로 **광선이 벽과만나는좌표**와 **광선의 방향**적인 요소를 담고 있는 구조체 입니다.
<img src="https://kirkim.github.io/assets/img/cub3d/cub34.png" alt="2nd_array_direction" width="85%">

* **2D 지도**가 **2차원 배열**형식으로 만들어져 있기 때문에 <rd>상하가 기존에 생각하던 방향과 반대로</rd>되어 있습니다. **삼각함수**를 이용하여 올바르게 계산하기 위해서 <rd>"0도 ~ 180도"</rd>는 **윗방향**이아닌 `facingDown`(아래를 바라볼때)의 **범위**로 생각해야합니다.
* `ray_init`함수는 이러한 `t_ray`구조체를 초기화해주는 함수입니다.

* * *
<h2 style="color:#0e435c;">(4) </h2>