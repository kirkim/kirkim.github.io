---
layout: post
title:  "[cub3d](9)3D벽 구현하기"
subtitle:   ""
date: 2021-07-01 02:45:51 +0900
categories: 42seoul
tags: cub3d
comments: true 
---

* * *
<h1>1️⃣ 목표</h1>

* 지금까지 **2D미니맵**을 구현하였습니다.
* 이전 포스트에서도 언급하였지만 <rd>레이케스팅</rd>기법의 3D는 가짜 3D입니다.
* 화면상 **"한열(column)당 한가지의 정보"**만 있으면 됩니다. 정확하게는 **"열(column) x 타일사이즈(TILE_SIZE)당 한가지의 정보"**만 있으면 3D화면으로 확장시킬 수 있습니다.
* 그 정보들은 이미 **2D미니맵**을 구현하면서 설정되었고 그 정보들을 이용해서 구현만 하면됩니다.
<br><br>

* * *
<h1>2️⃣ 3D랜더링 순서 정하기</h1>

<h2 style="color:#0e435c;">(1) 단순하게 생각할 수 있는 순서 및 방법</h2>
* 이전에 구현한 "<rd>player</rd>와 <rd>광선(ray)</rd>"는 <rd>미니맵</rd>이 랜더링된 후에 **덧칠하는 느낌**으로 그려지도록 했습니다.
* 이러한 **덧칠하는 방벙**으로 구현하려고하면 <rd>3D랜더링</rd>이 가장 먼저 실행되어야합니다. 하지만 **3D랜더링**을 하기 위해서는 <rd>광선(ray)</rd>을 구현하면서 설정해줬던 정보들이 필요합니다. 그렇기 때문에 지금 생각할 수 있는 방법은 다음과 같이 2가지 입니다.
    1. "2D미니맵랜더링" -&gt; "3D화면랜더링" -&gt; "2D미니맵랜더링" 으로 마지막에 <rd>2D미니맵</rd>을 한번 더 덧칠해주는 방법
    2. "3D화면"을 기준으로 다시 함수를 구현하 그정보를 이용한 "2D미니맵랜더링"함수 구현하기
* **1번**의 방법은 가장 단순하게 해결할 수 있지만 **성능상 가장 비효율**적인 방법입니다.
* **2번**의 방법이 괜찮을 것 같지만 추가적으로 <rd>각각의 광선(ray)<rd>의 정보를 담고 있는 <rd>ray구조체 배열</rd>을 만들어 줘야합니다. 어쩔수 없이 **광선(ray)**을 하나씩 살피는 **반복문**도 필요합니다. <b style="font-size:85%"> (3D화면또한 **한 열**씩 그려지는데 **그 열**의 위치가 **2D맵**이 그리는 **열**과 반드시 같지 않기 때문에 덮여 씌어지는일이 생길 수 있고 어쩔 수없이 **배열과 추가적인 반복문**이 필요합니다.)</b> 결론적으로 코드를 고치는 것이 불편할 뿐더러 **효율**도 그다지 좋아보이지 않습니다.

<h2 style="color:#0e435c;">(2) 이상적인 방법</h2>

* 이 방법이 **이상적인 방법**이라고는 확신하지는 못하지만 그래도 위의 방법보다는 이상적인 방법이라고 생각합니다.
    1. `hook_loop함수`가 호출될때마다 **프로젝트 화면**을 <rd>특정색</rd>으로 **세팅**해줍니다.
    2. **반복문**이 돌면서 <rd>각각의 광선(ray)</rd>마다 "2D맵"과 "3D화면"을 동시에 그려줍니다.
    3. 단, "3D화면"은 <rd>특정색</rd>인 곳만 그려줍니다. <b style="font-size:85%">(2D미니맵위에 덧칠하는 것을 막아줌)</b>

<h2 style="color:#0e435c;">(3) 특정색을 채우는 반복문</h2>

```c
for (int y = 0; y < WINDOW_HEIGHT; y++)
{
    for (int x = 0; x < WINDOW_WIDTH; x++)
        god->img.data[WINDOW_WIDTH * y + x] = 0x111111;            
}
```

* `0x111111`색으로 채워줬습니다. **2D맵**을 그려주기 이전에만 위치하면 됩니다.

<h2 style="color:#0e435c;">(4) 3D랜더링함수 매개변수</h2>

* **각각의 광선**마다 **2D맵**과 동시에 그려줄 계획입니다. <b style="font-size:85%">(ray구조체 배열을 만들기 싫다면 어쩔 수 없이 동시에 그려줘야 합니다.)</b>
* **3D랜더링함수**는 **화면상 열(column)**의 위치를 매개변수로 받아야합니다.

```c
/* 3D랜더링 함수의 함수원형 */
void render_3D_project_walls(t_god *god, int ray_num);
```

* **화면상 열(column)**은 **광선(ray)**의 순번을 매개변수로 받으면 **3D함수**내부적으로 처리하도록 구현했습니다.
* **광선(ray)**읜 순번을 적절히 넘겨주기 위해 기존의 **ray(광선)**을 그려주는 함수를 수정하였습니다.

```c
/* 수정된 draw_ray함수 */
void    draw_ray(t_god *god)
{
    double angle;
    double maxAngle;
    int i;

    i = 0;
    angle = god->player.rotationAngle - (RAY_RANGE / 2.0);
    maxAngle = god->player.rotationAngle + (RAY_RANGE / 2.0);

    while (i < RAY_COUNT)
    {
        draw_one_ray(god, angle, i);
        angle += RAY_RANGE / RAY_COUNT;
        i++;
    }
}
```

* 기존에 광선을 **동시에 2개씩**그려주는 반복문을 왼쪽부터 **하나씩**그려주는 반복문으로 수정해 주었습니다.
* **3D랜더링함수**가 `draw_one_ray함수`에 위치할 계획입니다.

<h2 style="color:#0e435c;">(5) 3D랜더링함수 최종위치</h2>

```c
void    draw_one_ray(t_god *god, double angle, int i)
{
    /* 코드 생략 */

    draw_line(god, god->ray.wall_hitX - god->player.x, god->ray.wall_hitY - god->player.y);
    render_3D_project_walls(god, i);
}
```

* <rd>각각의 광선(ray)</rd>에 대한 정보는 `draw_one_ray함수`에 와서야 결정이 됩니다. 그렇기 때문에 <rd>3D랜더링함수의 위치</rd>를 이 함수의 끝쪽으로 최종결정하였습니다.
* `draw_line함수`(광선(ray)을 그리는 함수)와 `render_3D_project_walls함수`의 위치는 서로 바뀌어도 상관없습니다.
<br><br>

* * *
<h1>3️⃣ 3D랜더링함수 구현하기</h1>
<h2 style="color:#0e435c;">(1) </h2>

```c
void render_3D_project_walls(t_god *god, int ray_num)
{
    double distance_project_plane = (WINDOW_WIDTH / 2) / tan(FOV_ANGLE / 2);
    double projected_wall_height = (TILE_SIZE / god->ray.distance) * distance_project_plane;

    int wallStripHeight = (int)projected_wall_height;

    int wall_top_pixel = (WINDOW_HEIGHT / 2) - (wallStripHeight / 2);
    wall_top_pixel = wall_top_pixel < 0 ? 0 : wall_top_pixel;

    int wall_bottom_pixel = (WINDOW_HEIGHT / 2) + (wallStripHeight / 2);
    wall_bottom_pixel = wall_bottom_pixel > WINDOW_HEIGHT ? WINDOW_HEIGHT : wall_bottom_pixel;

    int color = god->ray.wasHit_vertical ? 0xFFFFFF : 0xAAAAAA;
    for (int y = wall_top_pixel; y < wall_bottom_pixel; y++)
        for (int x = 0; x < WALL_STRIP_WIDTH; x++)
            if (god->img.data[WINDOW_WIDTH * y + (x + ray_num * WALL_STRIP_WIDTH)] == 0x111111)
                god->img.data[WINDOW_WIDTH * y + (x + ray_num * WALL_STRIP_WIDTH)] = color;
    
}
```

* `FOV_ANGEL`은 <rd>시야각</rd>을 나타내며 `60 * (PI / 180.0)`으로 정의하였습니다.
<img src="https://kirkim.github.io/assets/img/cub3d/cub42.png" alt="distance_project_plane">

* `distance_project_plane`은 **화면(모니터)과 사용자**사이의 거리입니다. `WINDOW_WIDTH`와 `FOV_ANGEL`을 알면 간단하게 구할 수 있습니다.
<img src="https://kirkim.github.io/assets/img/cub3d/cub43.png" alt="wallStripHeight">

* `wallStripHeight`는 **화면(모니터)상에 보이는 벽의 높이**입니다. 거리(god->ray.distance)와 **반비례**하며 