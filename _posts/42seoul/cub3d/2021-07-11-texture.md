---
layout: post
title:  "[cub3d](13)"
subtitle:   ""
date: 2021-07-11 02:45:51 +0900
categories: 42seoul
tags: cub3d
comments: true 
---

* * *
<h1>1️⃣ 목표</h1>

* 저장된 `xpm주소`를 `mlx함수`를 이용하여 적절한 데이터를 얻는 것이 목표입니다.
* **적절한 데이터**란 <rd>픽셀당 색(int), 텍스쳐 높이, 텍스쳐 넓이</rd>입니다. **텍스터구조체**는 다음과 같이 정의하였습니다.

```c
typedef struct  s_texture
{
    char		*tex_path;
	int			*texture;
	double		width;
	double		height;
}               t_texture;
```
이 텍스쳐 구조체는 `t_parse`구조체가 배열로 가지고 있으며 **각각의 인덱스마다** `tex_path`(xpm주소)를 저장해놨었습니다.

```c
typedef struct  s_parse
{
    t_texture   tex[TEXTURE_COUNT];
    
    /* 코드 생략 */

}               t_parse;
```
<br><br>

* * *
<h1>2️⃣ xpm파일주소 읽기</h1>
<h2 style="color:#0e435c;">(1) 텍스쳐읽기 함수1 (load_texture)</h2>

```c
void		load_texture(t_god *god)
{
	int		i;
	t_img	img;

	i = -1;
	while (++i < TEXTURE_COUNT)
	{
		god->parse.tex[i].texture =
			load_image_malloc(god, god->parse.tex[i].tex_path, &img, i);
		free_memory(god->parse.tex[i].tex_path);
	}
}
```

* `TEXTURE_COUNT`개의 텍스쳐파일을 하나씩 읽어드립니다.
* 이 함수에서만 쓰일(임시) `img구조체`를 선언하였습니다.
* 읽기를 완료한 `god->parse.tex[i].tex_path`(텍스쳐 주소)는 이전에 `parse함수`에서 **동적할당**을 하였기 때문에 <rd>메모리 해제</rd>를 해주어야 합니다.

* * *
<h2 style="color:#0e435c;">(2)  텍스쳐읽기 함수2 (load_image)</h2>

```c
static int	*load_image_malloc(t_god *god, char *path, t_img *img, int i)
{
	int		col;
	int		row;
	int		*result;

	if (!(img->ptr = mlx_xpm_file_to_image(god->mlx,
					path, &img->img_width, &img->img_height)))
		exit_error(god, ERROR, "WRONG TEXTURE!");
	god->parse.tex[i].width = img->img_width;
	god->parse.tex[i].height = img->img_height;
    
	img->data = (int *)mlx_get_data_addr(img->ptr,
			&img->bpp, &img->line_size, &img->endian);
	result = (int *)malloc(sizeof(int) * (img->img_width * img->img_height));
	row = -1;
	while (++row < img->img_height)
	{
		col = -1;
		while (++x < img->img_width)
		{
			result[img->img_width * row + col] = img->data[img->img_width * row + col];
		}
	}
	mlx_destroy_image(god->mlx, img->ptr);
	return (result);
}
```

* 각각의 텍스쳐당 한번씩 **이 함수**를 한번씩 호출합니다.
* `mlx_xpm_file_to_image함수`를 임시 **img구조체**에 저장해줍니다. 이 함수에서는 <rd>각 픽셀당 색</rd> 뿐만아니라 <rd>높이 픽셀, 넒이 픽셀</rd>값도 얻을 수 있습니다.
* `img->data`와 크기가 똑같은 `result`변수를 **동적할당**하여 **반복문**을 통해 데이터들을 복사해줍니다. 그리고 `mlx_destroy_image함수`를 통해 `img구조체`를 초기화하였습니다.
* `img구조체`변수를 재사용이 아닌 각 텍스쳐마다 선언해주어 사용하면 굳이 `result`변수를 만들어 복사할 필요가 없을 것아닌가 하고 생각했습니다. 하지만 우리가 필요한 것은 `img->data`일 뿐이고 <rd>프로그램을 종료</rd>할 때 `mlx_dextroy_image함수`를 **각각의 텍스쳐img**마다 호출하여야 합니다. 이것은 실수할 가능성이 크고 번거롭습니다. 어짜피 <rd>result에 복사하는 반복문</rd>은 프로그램 실행할 때 한번 이루어지는 것이기 때문에 부담이 없을 것이라고 생각합니다.
<br><br>

* * *
<h1>3️⃣ xpm파일 화면에 출력해보기</h1>
<h2 style="color:#0e435c;">(1) 텍스쳐 크기로 출력</h2>

```c
int main(int argc, char **argv)
{
	/* 코드 생략 */

	god.win = mlx_new_window(god.mlx, 64, 64, "mlx_title");
	god.img.ptr = mlx_new_image(god.mlx, 64, 64);
	god.img.data = (int *)mlx_get_data_addr(god.img.ptr, &(god.img.bpp), &(god.img.line_size), &(god.img.endian));
	
	/ * 코드 생략 */

	load_texture(&god);
	
	for (int row = 0; row < 64; row++)
    {
        for (int col = 0; col < 64; col++)
        {
            god.img.data[64 * (row) + (col)] = god.parse.tex[1].texture[64 * row + col];
        }
    }
    mlx_put_image_to_window(god.mlx, god.win, god.img.ptr, 0, 0);
	
	/* 코드 생략 */
```

* `tex[1]`에 저장된 **텍스쳐**의 높이와 넓이는 각각 <rd>64픽셀</rd>이였습니다. <b style="font-size:85%">(`printf()`함수로 **텍스쳐구조체**에 저장된 width와 height를 확인해보면 됩니다.)</b>
* 하지만 항상 크기를 `64 x 64`의 크기로 사용할 수 없습니다. 거리에 따라 <rd>크기, 방향</rd>이 다르게 출력되어야 합니다.
<h2 style="color:#0e435c;">(2) 윈도우 크기로 출력</h2>

* **텍스쳐의 크기**를 **윈도우 크기**에 맞춰서 <rd>보정</rd>시켜주면 됩니다. 다음과 같이 보정한 색을 반환하는 `find_color함수`를 구현하였습니다.

```c
int		find_color(t_god *god, int col, int row)
{
	int color;
	int height = god->parse.tex[1].height;
	int width = god->parse.tex[1].width;
	int result_row = (height * row) / WINDOW_HEIGHT;
	int result_col = (width * col) / WINDOW_WIDTH;
	color = god->parse.tex[1].texture[width * result_row + result_col];
	return (color);
}
```

* `보정된 y좌표 = (텍스쳐높이 * y좌표) / 윈도우 높이;`의 연산식으로 보정해주면 됩니다.
<h3 align="middle" style="color:#0e435c;">&lt; 윈도우크기로 보정되어 출력된 모습 &gt;</h3>
<img src="https://kirkim.github.io/assets/img/cub3d/cub50.png" alt="xpm_correct_window_size">